import pandas as pd

class FilterHandler:
    def __init__(self, df, mapping_path):
        """
        :param df: Pandas DataFrame containing standardized data.
        :param mapping_path: Path to JSON file containing column mappings & metadata.
        """
        self.df = df.dropna(axis=1, how="all")  # Drop empty columns
        self.mappings = self._load_mappings(mapping_path)
        self.date_columns = self._identify_columns_by_type("date")
        self._update_missing_metadata()

    def _load_mappings(self, mapping_path):
        """Loads column mappings including metadata."""
        try:
            with open(mapping_path, "r", encoding="utf-8") as f:
                return json.load(f)
        except FileNotFoundError:
            print("Warning: Mapping file not found. Using default categorization.")
            return {}

    def _identify_columns_by_type(self, column_type):
        """Identifies columns by type (e.g., 'date', 'numerical')."""
        return [col for col, meta in self.mappings.items() if meta.get("type") == column_type and col in self.df.columns]

    def _update_missing_metadata(self):
        """If columns are missing in the metadata file, attempt to categorize them dynamically."""
        for column in self.df.columns:
            if column not in self.mappings:
                sample_value = self.df[column].dropna().iloc[0] if not self.df[column].dropna().empty else "N/A"
                suggested_category = ai_suggest_column_category(column, sample_value)
                self.mappings[column] = suggested_category  # Store new mapping dynamically

                # Save updated mappings to file
                with open("column_mappings.json", "w", encoding="utf-8") as f:
                    json.dump(self.mappings, f, indent=4)

    def validate_kpi_columns(self, kpi_formula):
        """
        Validates that all columns in a KPI formula belong to the correct data category.
        :param kpi_formula: The formula generated by AI.
        :return: Boolean indicating validity and a warning message if needed.
        """
        invalid_columns = []
        for column in kpi_formula.get("variables", {}):
            category = self.mappings.get(column, {}).get("category", "Uncategorized")
            
            if "Pressure" in category and "Sum" in kpi_formula["formula"]:
                invalid_columns.append(column)
            if "Chemical Volume" in category and "Average" in kpi_formula["formula"]:
                invalid_columns.append(column)

        if invalid_columns:
            return False, f"Warning: The following columns may not be appropriate for the KPI calculation: {invalid_columns}"
        return True, "KPI is valid."

    def get_available_filters(self):
        """
        Detects possible filters, classifying numerical columns by category.
        :return: Dictionary of available filters (categorical, numerical by type, date, groups).
        """
        available_filters = {"categorical": [], "numerical": {}, "date": self.date_columns, "groups": {}}

        for column, meta in self.mappings.items():
            if column in self.df.columns:
                category = meta.get("category", "Uncategorized")
                group = meta.get("group", "None")
                
                if meta.get("type") == "numerical":
                    if category not in available_filters["numerical"]:
                        available_filters["numerical"][category] = []
                    available_filters["numerical"][category].append(column)
                elif meta.get("type") == "categorical":
                    available_filters["categorical"].append(column)
                
                if group != "None":
                    if group not in available_filters["groups"]:
                        available_filters["groups"][group] = []
                    available_filters["groups"][group].append(column)

        return available_filters
    
    def apply_filters(self, filters):
        """
        Apply user-defined filters dynamically.
        :param filters: Dictionary containing filter parameters.
        :return: Filtered DataFrame.
        """
        filtered_df = self.df.copy()

        # Apply categorical filters
        for column, value in filters.get("categorical", {}).items():
            if column in filtered_df.columns and value != "All":
                filtered_df = filtered_df[filtered_df[column] == value]

        # Apply numerical range filters
        for column, range_values in filters.get("numerical", {}).items():
            if column in filtered_df.columns and isinstance(range_values, list) and len(range_values) == 2:
                filtered_df = filtered_df[
                    (filtered_df[column] >= range_values[0]) & 
                    (filtered_df[column] <= range_values[1])
                ]
                
        # Apply date range filters
        for column, date_range in filters.get("date", {}).items():
            if column in filtered_df.columns:
                filtered_df = filtered_df[
                    (filtered_df[column] >= pd.to_datetime(date_range[0])) & 
                    (filtered_df[column] <= pd.to_datetime(date_range[1]))
                ]

        return filtered_df
